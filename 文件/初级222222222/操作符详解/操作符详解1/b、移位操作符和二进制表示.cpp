#define _CRT_SECURE_NO_DEPRECATE 1
#include<stdio.h>

//  <<  左移操作符      左边丢弃，右边补0 （整体向左推一位，最左边的一位被推没了，最右边一位补0）                
//                                                              
//  >>  右移操作符      1、算术右移     右边丢弃，左边补原符号位             对于正数来说，算术右移和逻辑右移是一
//                      2、逻辑右移     右边丢弃，左边补0                    样的，但是编译器默认的是算术右移
//
//      右移操作符  视线往左看一位（舍弃最右一位），32位比特位就缺一位了，所以在最左位上补上原符号位（相对右移）（把这一堆数字向右推了一位）

int much(int a)
{
	//printf("传参 %d\n", a);
	int i = 0;
	int count = 0;
	for (i = 0; i < 32; i++)               //0000 0000 0000 0100 0100 0011 0111 0001
	{                                      //1111 1111 1111 1011 1011 1100 1000 1111
		if (1 == (a & 1))
		{
			count++;
		}
		a = a >> 1;    //把高位不断向最右地位推进，再利用 &1 来判断最低位是否为1，循环32次之后就可以知到总共有多少个1
	}
	return count;
}




int main2()
{
//右移操作

	int a = 16;
	int b = a >> 2;  // a 右移两位（二进制位）
	                 //原数      0000 0000 0000 0000 0000 0000 0001 0000         =  16      
	                 //移完之后  0000 0000 0000 0000 0000 0000 0000 0100         =  4             正数右移好像有除以2的效果
	printf("b=%d\n", b);

	//
	//整数的二进制位表示有：原码、反码、补码， 正数的原码、反码、补码相同
	// 
	// 以 -1 为例
	// 原码  1000 0000 0000 0000 0000 0000 0000 0001
	// 反码  1111 1111 1111 1111 1111 1111 1111 1110   符号位不变，其余位按位取反
	// 补码  1111 1111 1111 1111 1111 1111 1111 1111   反码加一就是补码   此补码以十六进制换算就是 ff ff ff ff   一个f是15，就是1111，八个f就是32个1  
	//                                                 可以点击F10 -- 调试 -- 窗口 -- 内存 -- 输入 &某个变量 即可查看其在内存中的存储形式
	//储存到内存的是补码
	//
	// 当右移一位时就还是  1111 1111 1111 1111 1111 1111 1111 1111  ，所以还是 -1
	//



//左移操作
    //
	// 比如说5
	//   0000 0000 0000 0000 0000 0000 0000 0101      = 5  
	//   0000 0000 0000 0000 0000 0000 0000 1010      = 10      正数左移好像有乘以二的效果
	//




//注意：移位操作符可以移一位、两位、三位......但是不能移动负数位。
//      比如：num >> -1     是error的，是未定义的，是编译器看不懂的
//注意：移位操作符只能作用于整数




	//练习题： 计算某个数二进制位中的1的个数
	int mou = 0;
	scanf("%d", &mou);
	mou = much(mou);
	printf("%d\n", mou);


	return 0;
}

