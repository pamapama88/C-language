#define _CRT_SECURE_NO_DEPRECATE 1
//操作符
//算术操作符
//+ - * / %(取模）     5/2=2  五除二得到的是商2；   5%2=1  五模二得到的是余数1(五取模为一)
//移位操作符
//>> <<
//位操作符
//& ^ |    (中间还有个 ^ 别忽略了，是三个)
//赋值操作符
//=  +=  -=  *=  /=  &=  ^=  |=  >>=  <<=


 
#include<stdio.h>
#include<string.h>

int main()
{
	int a = 5 % 2;
	printf("%d\n", a);
//移位操作符
	a << 1;
//整型1占四个字节即32个比特位，
//000000000000000000000001
//左移操作符就是把他往左移一位，然后后面加一个零，保持三十四位不变，最左边的零删了去，于是变成了
//0000000000000000000000000000010
//即2
//但是a这个时候是不变的，你可以b=a<<1;所以b变了，但a不变






	//   &  按位与
	//   |  按位或
	//   ^  按位异或
	//（二进制）位操作符 




//   &  按位与
	int e = 3;      //3的二进制是011
	int f = 5;      //5的二进制是101
	int g = e & f;  //按位与就 是001，即1.
	                //因为在C中0为假非0为真，只有两个数的同一位都是真的时候，才是真，否则为假，所以3和5合起来就是001
	printf("%d\n", g);




//   |  按位或
	int h = 3;       //011
	int j = 5;       //101
	int k = h | j;   //111
	printf("%d\n", k); //即有一个真，或的结果就是真，即111，（1*2^0+1*2^1+1*2^2=1+2+4=7)




//   ^  按位异或
	//异或的计算规律
	//对应的二进制位相同，则为0
	//对应的二进制位相异，则为1

	int l = 3;     //011
	int m = 5;     //101
	int n = l ^ m; //110     (1*2^1+1*2^2=2+4=6)
	printf("%d\n", n);



//赋值操作符
	//  = 赋值   ==判断相等
	//a=a+10 和 a+=10 完全等价    同理a-=20和a=a-20也一样  
	//再同理  a=a&2 和 a&=2 完全等价
	//+=  -=  *=  /=  &=  ^=  |=  >>=  <<=  所有这些成为复合赋值符号



//另外还有 单目操作符（如 a+b 有两个操作数，叫双目操作符     int a=1 中 = 就是弹幕操作符    同理 -2 中的 - 也是单目操作符）
	// !   逻辑反操作                            把假变成真，把真变成假
    // -   负值                                  
	// +   正值                                  
	// &   取地址                                
	// sizeof   操作数的类型长度（以字节为单位） 计算的是变量或者是类型所占空间的大小，单位是字节
	// ~   对一个数的二进制按位取反              波浪号，按位取反顾名思义就是把每个二进制位取反，比如101011变成了010100
	// --  前置、后置--                          
	// ++  前置、后置++                          
	// *   间接访问操作符（解引用操作符）        
	//（类型）  强制类型转换      




// !   逻辑反操作                            把假变成真，把真变成假
	int aa = 66;
	printf("%d  这是!aa的值\n", !aa);          //66是非0的数，所以变成了0
	int bb = 00;
	printf("%d\n", !bb);

	int cc = -aa;
	printf("%d\n", cc);   //正号都会省略




// ㈠   sizeof   操作数的类型长度（以字节为单位） 计算的是变量或者是类型所占空间的大小，单位是字节
	printf("%d\n", sizeof(666666666666));
	printf("%d\n", sizeof(aa));
	printf("%d\n", sizeof aa);    //当sizeof跟变量名的时候可以不加括号，但跟int这种函数的时候必须加括号
	printf("%d\n", sizeof(int));    
	  

	int chuan[10] = { 0 };    //有十个整形的数组，一个整型占四个字节，十个就占四十个字节

	printf("%d\n", sizeof(chuan));
	//那么我们能不能用sizeof算出数组的字符个数呢
	//个数=数组总大小/类型所占空间的大小
	int geshu = 0;
	geshu = sizeof(chuan) / sizeof(chuan[0]);   //类型所占空间大小用第一个字符大小(数组中每个元素都是一样的)表示即chuan[0].(详见“数组”文件）
	printf("这个个数=%d\n", geshu);



//~ 波浪号的使用方法
	int aaa = 0;     //0是整型，占四个字节，即32个比特位，取反后就有了32个1
	int bbb = ~aaa; //所以bbb应该为11111111111111111111111111111111
	//只要是整数在内存中存储的时候，存储的都是二进制的补码
	// 对于 正数 来说，他的原码反码补码相同，
	// 负数  存的是补码
	//bbb在这里是有符号的整形，他的最高位代表他的符号位，1为负数，0位正数
	// 但我们使用的、打印的是源码
	// 原码符号位不变，其他位按位取反得到反码，反码加一得到补码
	// 故补码（11111111111111111111111111111111）减一得到反码（11111111111111111111111111111110），反码最高位不变其他位取反得到源码（10000000000000000000000000000001）
	// 这就是内存中的0（aaa）的补码转换位原码并赋值到bbb过程很明显10000000000000000000000000000001转化为十进制为-1
	//原码   直接按照正负写出来的二进制序列
	//反码   原码的符号位不变，其他位按位取反得到的
	//补码   反码加一得到的

	//               原码----------------------------------->反码---------------------->补码
	//    直接按照正负写           原码的符号位不变                      反码+1
	//    出来的二进制序列         其他位按位取反
    //             
	//     -2
	// 10000000000000000000000000000010---原码
	// 11111111111111111111111111111101---反码
	// 11111111111111111111111111111110---补码



	printf("%d\n", bbb);  //打印出-1

//++、--的前置和后置使用方法
		//后置
		int aaaa = 10;
		int bbbb = aaaa++;  //后置++，先使用，再++     先把aaaa的值赋给bbbb，然后再给aaaa+1
		printf("%d\n", bbbb);  //bbbb=10
		printf("%d\n", aaaa);  //aaaa=11
		//前置
		int cccc = 10;
		int dddd = ++cccc;  //前置++，先++，再使用     先给cccc+1，然后把cccc的值赋给dddd
		printf("%d\n", cccc);  //cccc=10
		printf("%d\n", dddd);  //dddd=11
		//--的使用方法和++相同



//(类型)  	强制类型转换   
		//int asd = 3.14;时会报错的
		int asd = int(3.14);  //将原来的double类型的3.14转换为int类型，，不过一般不建议转换，能不转换就不转换



//关系操作符
		//  >
		//  *<
		//  >=
		//  <=
		//  !=   同于测试不相等
		//  ==   用于测似相等
		  


//逻辑操作符
		//  &&  逻辑与    判断真假
		//  ||  逻辑或    判断真假



// &&  逻辑与
		int luo = 3;
		int ji = 5;
		int yu = luo && ji;  //当luo为真,且ji为真,才判断为真
		//判断后的假用0来表示,,真用1表示
		//所以yu就等于1
		printf("%d\n", yu);

// ||  逻辑或   判断真假
		//只要有一个真就判断为真,两个都为假才判断为假





//条件操作符(三目操作符)
		//exp1 ? exp2 : exp3  如果表达式1的结果为真,表达式2执行,表达式2的结果为整个表达式的结果...如果表达式1的结果为假,表达式3执行,表达式三的结果为整个表达式的结果

		int 数1 = 66;
		int 数2 = 99;
		int 较大 = 0;
			较大 = 数1 > 数2 ? 数1 : 数2;


//逗号表达式
		//exp1,exp2,exp3, ....,expN





//下标引用.函数调用和结构成员
//	[]       ()       .     ->
			//[]  下标引用操作符
			int made[10] = { 0 };
			made[4];  //这里是访问数组中的第五个数,其中[]就是下标引用操作符

			//()  函数调用操作符
			// 展示有点费劲,详见文件:函数  
			// 中 sum=add(a,b);的那个括号
			// 
			// 
			                                                       //此文件中漏讲了4个操作符,他们是
																  //  &  取地址操作符
			                                                     //   *
			                                                    //    .
			                                                   //     ->




	return 0;
}